你是一名 **资深全栈工程师**。  
现在我已经有：

- 一个 **可运行的 FastAPI 后端**
    - 提供 `/document`、`/chat`、`/versions`、`/versions/{id}/rollback` 等接口
- 一个 **可运行的 React + Ant Design 前端**
    - 左侧 Markdown 编辑区
    - 右侧对话区
    - 版本弹窗
    - 当前使用的是 **前端 mock 数据与 setTimeout 模拟**

---

## ⚠️ 非常重要的总原则（必须遵守）

1. **不允许重构工程结构**
2. **不允许重写组件**
3. **只做三件事**：
    - 新增 API 调用层
    - 替换 mock 为真实请求
    - 补充必要的 loading / error 状态
4. **不引入新框架（Redux / React Query 等）**

---
## 一、联调目标（你必须理解）

用户在浏览器中的完整链路应为：
1. 页面加载
    - 前端调用 `GET /document`
    - 初始化 Markdown 内容
2. 用户手动编辑 Markdown 并点击保存
    - 前端调用 `PUT /document`
    - 后端生成新版本
3. 用户在对话区输入消息
    - 前端调用 `POST /chat`
    - 后端返回 **修改后的完整 Markdown**
    - 前端刷新 Markdown 编辑区
4. 用户打开版本面板
    - 前端调用 `GET /versions`
5. 用户点击某个版本回退
    - 前端调用 `POST /versions/{id}/rollback`
    - 前端刷新 Markdown 内容
        

---

## 二、前端需要完成的修改（重点）

### 1️⃣ 新增 API 封装层

请在 `src/` 下新增：
```
src/api/
├── http.ts      # axios 实例
├── document.ts  # /document 相关
├── chat.ts      # /chat
└── version.ts   # /versions
```

要求：

- 使用 axios
- baseURL 使用常量（如 `http://localhost:8000`）
- 每个文件只负责一类接口
- 写清楚 TS 类型

---

### 2️⃣ 替换 mock 行为（严格逐一替换）

#### MarkdownEditor

- 原来：本地 state 保存
- 现在：
    - 初始化：调用 `GET /document`
    - 保存：调用 `PUT /document`

#### ChatPanel

- 原来：
    - `setTimeout` 模拟 AI 回复
    - 本地拼接 Markdown
- 现在：
    - 调用 `POST /chat`
    - 使用返回的 `content_md` 更新 Markdown

#### VersionPanel

- 原来：写死版本号
- 现在：
    - 打开 Modal 时调用 `GET /versions`
    - 点击版本调用 `POST /versions/{id}/rollback`

---

### 3️⃣ 状态管理要求（不能偷懒）

- Markdown 内容：
    - 仍然由 `Home.tsx` 统一管理
- 子组件：
    - 通过 props 接收
- API 请求时：
    - 加简单 loading（Button loading / Spin 即可）
    - 出错用 `message.error`

---

## 三、后端需要确认 / 微调的点（如必要）

你可以：

- 确保所有接口返回 JSON 结构清晰
- 如字段命名不一致：
    - **前端适配**
    - 不要随意改后端接口含义
- 不增加新业务逻辑

---

## 四、联调顺序（必须按这个来）

1. `/document`（最简单）
2. `/chat`
3. `/versions`
4. `/rollback`
    

⚠️ 不允许并行乱改

---

## 五、代码注释要求（非常重要）

在所有从 mock → API 的地方，  
请加注释说明：

`// 原 mock 行为：xxx // 现在替换为真实后端 API 调用`

这是为了 **未来排查问题与演进**

---

## 六、验收标准（你必须确保）

当我同时启动：

`# backend uv run uvicorn app.main:app --reload  # frontend pnpm dev`

我可以：

- 刷新页面，看到后端返回的 Markdown
- 对话一次，文档被真实修改
- 打开版本列表，看到真实版本
- 回退版本后，文档发生变化
- 全流程 **不依赖任何 mock**
    

---

## 七、工程哲学（请你牢记）

- **联调不是重写**
- **联调是“替换”和“对齐”**
- 能跑 > 优雅
- 可理解 > 抽象

---

### ✅ 后续你可以自然演进到：

- WebSocket / Streaming
- 多文档 / 多用户
- Prompt 结构化（patch / section-level）

但现在，这一步 **只做联调，不做升级**。