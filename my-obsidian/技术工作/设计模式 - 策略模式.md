## 意图

将一组算法封装成独立的策略类（Strategy），让它们可以互相替换，且使得算法的变化独立于使用算法的客户（Context）。  
一句话：把“可变的行为”从主逻辑中抽离出来，放到策略对象里，按需切换。

## 结构（Participants）

- **Strategy（抽象策略）**：定义所有支持的算法的公共接口（方法签名）。
- **ConcreteStrategy（具体策略）**：实现 Strategy 接口的多个具体算法类。
- **Context（上下文）**：持有一个 Strategy 引用，通过该引用调用具体策略的方法；允许在运行时设置/切换策略。

##  什么时候使用

- 有很多相关的算法/策略，只是实现不同，但客户端代码要独立于这些算法。
- 希望在运行时选择算法或动态切换算法。
- 避免使用大量条件分支（if/else 或 switch）来选择行为。
- 算法需要被独立复用或测试。

## 优点与缺点

优点：

- 遵守单一职责和开放-封闭原则：算法独立封装，扩展新策略无需修改 Context。
- 减少条件分支，提高可读性与可维护性。
- 策略可以独立测试与复用。

缺点：

- 客户端必须知道不同策略并负责选择（可能需要额外配置或工厂）。
- 增加类/对象数量（每个策略一个类），结构更复杂。
- 如果策略间需要共享大量状态，可能会出现复制或复杂协作。

## 我的心得

Context可以把设置策略和执行策略的角色分开，比如画布的节点每一个都不一样，可以把画布看成Context
